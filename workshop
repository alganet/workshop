#!/usr/bin/env sh

# workshop, the module loader
#
# Loads modules and their dependencies, downloading them from a server
# if none is found locally.
#
workshop ()
{
	# Workshop needs at least two arguments to work
	if test -z "${2:-}"
	then
		return 0
	fi

	# Path to the executable that started workshop
	_executable="${workshop_executable:-${1}}"

	# Directory in which the workshop executable resides
	_executable_dir="$(dirname "${_executable}")"

	# Input module name or file path. Trim dashes from beginning.
	_input="${2##*-}"

	# Name of the module
	_main="$(basename "${_input}")"

	# Remove trailing file extension from main module
	_main="${_main%%.*}"

	# Default server to look for dependencies
	_master="https://raw.githubusercontent.com/alganet/workshop/master/"

	# Use default server if non has been provided
	_server="${workshop_server:-${_master}}"

	# List of modules already loaded
	_modules="${workshop_modules:-} : workshop "

	# List of modules to be loaded, include main module by default
	_dependencies="${workshop_modules:-}${workshop_modules:+ }${_main}"

	# Path to look for other modules
	workshop_path="${workshop_path:-${PWD}:${_executable_dir}}"

	# Absolute path to the executable that started workshop
	workshop_executable="$(
		cd "${_executable_dir}";pwd
	)/$(
		basename "${_executable}"
	)"
	shift 2 # Remove first two arguments, remaining are module arguments

	# Fail on errors and undefined variables. Don't expand glob patterns
	test -z "${workshop_unsafe:-}" || set -e
	set -uf

	# Don't expand glob patterns on zsh
	unsetopt NO_MATCH  >/dev/null 2>&1 || :

	# Split words by whitespace when expanding variables on zsh
	setopt SHWORDSPLIT >/dev/null 2>&1 || :

	# Don't stop until all dependencies are met
	while true 'Dependency Loop'
	do
		# Check each dependency
		for _dependency in ${_dependencies}
		do
			_dependency_status='ok'

			# Check if all dependencies were already loaded first
			for _dependency_check in ${_dependencies}
			do
				if test "${_modules#*$_dependency_check}" != "$_modules"
				then
					if test "${_dependency_status}" = 'ok'
					then
						continue
					fi
				else
						_dependency_status="${_dependency_check} missed"
				fi
			done

			# All dependencies loaded, get out
			if test "${_dependency_status}" = 'ok'
			then
				break 2 # Exit 'Dependency Loop'
			fi

			# Current dependency is already loaded, continue to next one
			if test "${_modules#*$_dependency}" != "$_modules"
			then
				continue
			fi

			# Looks for modules in the ${workshop_path}
			_found_module=''
			_ifs="${IFS}"
			IFS="${workshop_path_separator:-:}"
			for _part in ${workshop_path}
			do
				_file="$(echo "${_part}/${_dependency}").sh"

				if test -f "${_file}"
				then
					_found_module="${_file}"
					break # Module found, exit loop
				fi
			done
			IFS="${_ifs}"
			unset _ifs

			# If no module has been found, try to donwload it
			if test -z "${_found_module:-}" && test ! -z "${_server:-}"
			then
			    _temp_dir="$(
			    	mktemp -d \
			    	"${TMPDIR:-/tmp}/workshop.XXXXXX" 2>/dev/null
		    	)"
			    if test -z "${_temp_dir}"
				then
					_temp_dir="${TMPDIR:-/tmp}/workshop."$(
						od -An -N2 -i /dev/random
					)
				    mkdir -m 700 "${_temp_dir}"
				fi
				_remote_url="${_server}${_dependency}.sh"
				_found_module="${PWD}/${_dependency}.sh"
				_temp_module="${_temp_dir}/${_dependency}.sh"

				# Tests if current shell can check if commands exist
				if command -v workshop >/dev/null 2>&1
				then
					# Check for popular HTTP download tools
					if command -v curl >/dev/null 2>&1
					then
						curl --fail -L "${_remote_url}" \
							2>/dev/null > "${_temp_module}" ||
								_code=$?
					elif command -v wget >/dev/null 2>&1
					then
						wget -qO- "${_remote_url}" \
							2>/dev/null  > "${_temp_module}" ||
								_code=$?
					else
						# Module cannot be found
						return 127
					fi

					# Tests if downloaded file is a workshop module
					_head=
					test ! -f "${_temp_module}" ||
						_head="$(head -n1 "${_temp_module}")"

					if test "${_head}" = "#!/usr/bin/env workshop" &&
						test "${_code:-0}" = 0 &&
						"${SHELL}" -n "${_temp_module}" >/dev/null 2>&1
					then
						cp "${_temp_module}" "${_found_module}"
					elif test -f "${_temp_module}"
					then
						# If not a valid module, delete it
						rm "${_temp_module}"
						return 127
					fi
				else
					return 127
				fi
			fi

			_required=''

			# Makes sure no one overrided the require function
			require ()
			{
				_required="${_required:-} ${*:-} "
			}

			# Dry-runs the module to check for errors
			"${SHELL}" -n "${_found_module}" >/dev/null 2>&1

			# Loads the module, calling its 'require' commands
			. "${_found_module}"

			# Add up newly found dependencies to list
			_dependencies="${_required:-} ${_dependencies:-}"
			# Add loaded module to list of dependencies met
			_modules="${_modules} ${_dependency} "
		done
	done

	if test ! -z "${_temp_dir:-}"
	then
		rm -Rf "${_temp_dir}"
	fi

	# Call module with arguments, if there is at least one
	if test -z "${1:-}"
	then
		"${_main}"
	else
		"${_main}" "${@}"
	fi
}

workshop "${0}" "${@:-}"
